# MySQL 笔记

[MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.cn/book/6844733769996304392)


InnoDB 中页大小一般为16KB = 16384字节。


## 行格式 ROW_FORMAT

- **COMPACT**
- **REDUNDANT**
- **行溢出格式**
- **Dynamic** （MySQL 8.0.x默认）和 **Compressed**


一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535(2^16 - 1)个字节！

`VARCHAR(M)` 中的`M` 指的是最多M 个字符，而不是字节。存储的字节需要根据 `CHARSET` 另算。

行格式需要处理的东西：变长字段（列数据字段边界鉴定）、NULL值处理（节省空间）、记录头信息。

页大小16KB，列中存储的数据长度可以达到65535字节，所以对于一个页中存放不下的记录需要特殊处理：**行溢出**。
即存列数据开始的一部分数据，在存一个指向溢出数据的“指针”。

MySQL 中规定一个页中至少存放两行记录。


## InnoDB 数据页结构

对16KB 页进行划分和组织（就是内存管理，这就是计算机!）。

页内快速定位主键值，经典二分法，将行记录进一步分组为 **SLOT** ，
**页内搜索** ：二分定位 **SLOT** 位置，遍历 **SLOT** 内的行记录。

通过 `File Handler` 中的校验和和 `File Trailer` 中的校验和来防止断电、宕机时带来的数据不完整。
（其实我一直不知道这种方法真的能防止断电这种一瞬间的事？这中所谓的数据安全、完整性，真的可行吗？🤔）


## B+ 树索引

通过索引在诸多数据页中定位到符合搜索条件的记录所在数据页，再通过 **页内搜索** 定位对于记录。
索引本身也是一种记录，通过 `record_type` 指明记录类型：

- **0** : 普通的用户记录
- **1** : 目录项记录，索引
- **2** : 最小记录
- **3** : 最大记录

索引记录值只有主键值和页号两个列。

一张表能存放数据的大致估算：假设B+ 树不超过4层，则通过索引查找一个记录最多进行4个页面的查找（3个索引页和一个用户记录页）

1. 估计索引页能存放的索引记录数量M = (16KB - 用于维护结构的数据大小) / 索引行结构的大小
2. 估计数据页能存放的用户记录数量N = (16KB - 用于维护结构的数据大小) / 用户数据行结构的大小
3. 4层的B+ 树能在最多4次磁盘交换的情况下找到数据的表大小为：N * M * M * M


### 聚簇索引 

- 使用记录主键值的大小进行记录和页的排序
- B+ 树的叶子节点存储的是完整的用户记录


### 二级索引

- 使用索引列的大小进行记录和页的排序
- B+ 树的叶子节点存储的并不是完整的用户记录，而只是索引列+主键这两个列的值。
- 目录项记录中不再是主键+页号的搭配，而变成索引列+主键+页号的搭配。


通过二级索引查找记录：

1. 在二级索引的B+ 树上找到对应的记录（索引列值和主键值）。
2. **回表** : 根据在二级索引的B+ 树中得到的主键值再到聚簇索引中找到对应的完整用户记录。

所以最多需要8次磁盘交换，如果查询条件是判断这个索引值是否存在，则对于存在的情况，则需要4次磁盘交换。


### 联合索引

- 使用多个索引列的大小进行记录和页的排序，按声明的顺序排序，如以 `(c1, c2, ...)` 为联合索引，则先按 `c1` 排序，再按 `c2` 排序
- B+ 树的叶子节点存储的并不是完整的用户记录，而只是 **多个** 索引列+主键的值。
- 目录项记录中不再是主键+页号的搭配，而变成 **多个** 索引列+主键+页号的搭配。



