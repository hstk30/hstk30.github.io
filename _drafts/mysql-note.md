# MySQL 笔记

[MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.cn/book/6844733769996304392)


InnoDB 中页大小一般为16KB = 16384字节。


## 行格式 ROW_FORMAT

- **COMPACT**
- **REDUNDANT**
- **行溢出格式**
- **Dynamic** （MySQL 8.0.x默认）和 **Compressed**


一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535(2^16 - 1)个字节！

`VARCHAR(M)` 中的`M` 指的是最多M 个字符，而不是字节。存储的字节需要根据 `CHARSET` 另算。

行格式需要处理的东西：变长字段（列数据字段边界鉴定）、NULL值处理（节省空间）、记录头信息。

页大小16KB，列中存储的数据长度可以达到65535字节，所以对于一个页中存放不下的记录需要特殊处理：**行溢出**。
即存列数据开始的一部分数据，在存一个指向溢出数据的“指针”。

MySQL 中规定一个页中至少存放两行记录。


## InnoDB 数据页结构

对16KB 页进行划分和组织（就是内存管理，这就是计算机!）。

页内快速定位主键值，经典二分法，将行记录进一步分组为 **SLOT** ，
**页内搜索** ：二分定位 **SLOT** 位置，遍历 **SLOT** 内的行记录。

通过 `File Handler` 中的校验和和 `File Trailer` 中的校验和来防止断电、宕机时带来的数据不完整。
（其实我一直不知道这种方法真的能防止断电这种一瞬间的事？这中所谓的数据安全、完整性，真的可行吗？🤔）


## B+ 树索引

通过索引在诸多数据页中定位到符合搜索条件的记录所在数据页，再通过 **页内搜索** 定位对于记录。
索引本身也是一种记录，通过 `record_type` 指明记录类型：

- **0** : 普通的用户记录
- **1** : 目录项记录，索引
- **2** : 最小记录
- **3** : 最大记录

索引记录值只有主键值和页号两个列。

一张表能存放数据的大致估算：假设B+ 树不超过4层，则通过索引查找一个记录最多进行4个页面的查找（3个索引页和一个用户记录页）

1. 估计索引页能存放的索引记录数量M = (16KB - 用于维护结构的数据大小) / 索引行结构的大小
2. 估计数据页能存放的用户记录数量N = (16KB - 用于维护结构的数据大小) / 用户数据行结构的大小
3. 4层的B+ 树能在最多4次磁盘交换的情况下找到数据的表大小为：N * M * M * M


### 聚簇索引 

- 使用记录主键值的大小进行记录和页的排序
- B+ 树的叶子节点存储的是完整的用户记录


### 二级索引

- 使用索引列的大小进行记录和页的排序
- B+ 树的叶子节点存储的并不是完整的用户记录，而只是索引列+主键这两个列的值。
- 目录项记录中不再是主键+页号的搭配，而变成索引列+主键+页号的搭配。


通过二级索引查找记录：

1. 在二级索引的B+ 树上找到对应的记录（索引列值和主键值）。
2. **回表** : 根据在二级索引的B+ 树中得到的主键值再到聚簇索引中找到对应的完整用户记录。

所以最多需要8次磁盘交换，如果查询条件是判断这个索引值是否存在，则对于存在的情况，则需要4次磁盘交换。


### 联合索引

- 使用多个索引列的大小进行记录和页的排序，按声明的顺序排序，如以 `(c1, c2, ...)` 为联合索引，则先按 `c1` 排序，再按 `c2` 排序
- B+ 树的叶子节点存储的并不是完整的用户记录，而只是 **多个** 索引列+主键的值。
- 目录项记录中不再是主键+页号的搭配，而变成 **多个** 索引列+主键+页号的搭配。


### 索引的使用

- **匹配最左的列** : 在搜索语句中各个列如果是联合索引中最左边连续的列，那么这个搜索语句可以利用这个联合索引。
- **匹配列前缀** : 因为字符串排序是逐个比较字符大小的，因此像 `like 'xx%'` 的搜索条件也能用到索引。
- **匹配范围值** : 如果是聚簇索引，则找到范围边界值的记录，然后沿着链表遍历到边界值；
    如果为二级索引，则在二级索引的B+ 树上找到范围边界值，**回表** 返回对应用户记录，
    然后在二级索引的B+ 树上沿着链表遍历到边界值。
- **精确匹配某一列并范围匹配另外一列** : 对于同一个联合索引，如果左边的列是精确查找，则右边的列可以进行范围查找
- **排序** 
- 让索引列在比较表达式中单独出现，`WHERE idx_col < 4 / 2` 优于 `WHERE idx_col * 2 < 4`
- 减少冗余和重复索引


#### 回表的代价

命中二级索引后，对应列的值在数据页中为顺序排列，因此顺序遍历指定范围内的列值为 **顺序I/O** ，
根据二级索引中得到的主键值 **回表** 找到对应的用户记录属于 **随机I/O** 。

**顺序I/O** 的数据页加载到内存，访问快； **随机I/O** 需要访问多个磁盘上不相邻的数据页，速度慢。
因此，如果根据二级索引找到的符合条件的主键值多的话，都需要 **回表** 的话， **随机I/O** 就多了，使用索引反而耗时，
不如直接在聚簇索引上进行 **全表扫描** 。

**查询优化器** 会根据统计信息决策使用 **全表扫描** 还是 **二级索引+回表** 。


### 如何挑选索引

- 只为用于搜索、排序或分组的列创建索引
- 选择基数大、数据重复少、分散的列作为索引列
- 为索引列选择合适的数据类型
- 对于类型为变长字符串的列建立索引可以指定索引的前缀长度，从而节省建立B+ 树的空间，代价是不能精确定位，
    但是，基于一个假设是存储的字符串的前缀大多是不相同的
- 为主键设置 **AUTO_INCREMENT** ，减少B+ 树节点分裂操作


## 数据目录


```
SHOW VARIABLES LIKE 'datadir';
```


一个数据库对应数据目录下一个子目录，
一张表对应子目录下若干文件

在MySQL 8.0.x 下，InnoDB 的表对应一个 `xx.ibd` 的文件，
MyISAM 的表对应 `xx.sdi` `xx.MYD` `xx.MYI` 三个文件。

文件的大小受文件系统支持的最大文件大小限制。

